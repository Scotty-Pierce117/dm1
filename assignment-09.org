  #+TITLE: STU Trees I
#+LANGUAGE: en
#+OPTIONS: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t
#+OPTIONS: html-postamble:nil
#+STARTUP: showeverything entitiespretty
#+SETUPFILE: theme-bigblow.setup

[[elisp:(find-file-other-window%20"generic-instructions.org")][Read Instructions]]
[[elisp:(progn%20(save-buffer)%20(browse-url-of-file%20(org-html-export-to-html)))][Export to HTML and Browse]]
[[elisp:(progn%20(save-buffer)%20(org-clock-report%201)%20(save-buffer))][Insert/Update Clock Summary Report]]
#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2019-03-07 Thu 15:28]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *2:35* |
#+END:

* Exercises
** DONE LDA
   CLOSED: [2019-03-05 Tue 17:20]
#+begin_note
  Alter the following =let= expression so that it creates the same list using
  =cons= rather than =list=.

#+BEGIN_SRC elisp :results raw
  (let ((a 1) (b 2) (c 3) (d 4))
    (list (+ a b) (/ d b) (- d a) (* c d)))
#+END_SRC

#+RESULTS:
(3 2 3 12)

#+end_note
#+begin_info
  Your answer goes here.
#+end_info

#+BEGIN_SRC elisp :results raw
  (let ((a 1) (b 2) (c 3) (d 4))
    (cons (+ a b) (cons (/ d b) (cons (- d a) (cons (* c d) nil)))))
#+END_SRC

#+RESULTS:
(3 2 3 12)
((3 . 2) 3 . 12)
(3 . 2)
(((+ a b)) / d b)
((+ a b) / d b)

** DONE SQI
   CLOSED: [2019-03-07 Thu 15:28]
#+begin_note
  Use =cons= to re-implement the =morphifyr= function more efficiently.
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
#+BEGIN_SRC elisp
(defun morphifyr (fun lst)
  (if (null lst)
      nil
    (append (list (funcall fun (first lst))) (morphifyr fun (rest lst)))))
(defun morphifyr-cons (fun lst)
  (if (null lst)
      nil
    (cons (funcall fun (first lst)) (morphifyr fun (rest lst)))))
  
    (equal (morphifyr (lambda (n) (- n 1)) '(3 4 5)) (morphifyr-cons (lambda (i) (- i 1)) '(3 4 5)))
#+END_SRC

#+RESULTS:
: t

** TODO LJP
#+begin_note
  Use =car=, =cdr=, and =cons= to re-implement the =prime-list-from-rle-list=
  function more efficiently.
:HINT:
  - Hint :: Think recursion. There are four cases to handle, the base case being
            when the passed-in rle-list is null.
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
#+BEGIN_SRC elisp :results raw
  (defun reconstitute-primes (rle-list)
  (loop for b in rle-list
        for n from 2
        unless (or (zerop b) (and (> b 1) (incf n (- b 1))))
        collect n))

(defun prime-list-from-rle-list (rle-list limit)
  (mapcar 'first
          (remove-if
           (lambda (x)
             (zerop (second x)))
           (mapcar* 'list
                    (number-sequence 2 limit)
                    (apply 'append
                           (mapcar (lambda (x)
                                     (if (> x 1)
                                         (make-list x 0)
                                       (list x)))
                                   rle-list))))))
(setq limit 4
      p100rle (list 1 1 0 1 0 1 3 1 0 1 3 1 0 1 3 1 5 1 0 1 5 1 3 1 0
                    1 3 1 5 1 5 1 0 1 5 1 3 1 0 1 5 1 3 1 5 1 7 1 3)
      got-it-right (equal (reconstitute-primes p100rle)
                          (prime-list-from-rle-list p100rle limit)))
#+END_SRC

#+RESULTS:
nil
nil
nil

** DONE YGT
   CLOSED: [2019-03-05 Tue 17:36]
#+begin_note
  Construct a binary search tree from the *words* (not the letters) of the phrase

: time flies on wings of lightning

  using dictionary order, inserting words in the order they appear in the
  phrase. Don\rsquo{}t try to balance the tree (see below).

  What is the *height* of this tree?
#+end_note
#+begin_info
             Time
            /    \
         flies  wings
            \   
            on   
             /
           of
           / 
       lightning
5    
#+end_info
** TODO LUM
#+begin_note
  Which of the above balanced BSTs is represented by the following list?
#+BEGIN_SRC elisp :results silent
  (so (cool (are (and) (binary)) (search (kind))) (trees (the) (wonderfully)))
#+END_SRC
#+end_note
#+begin_info
  I appears that this is a complete balanced binary tree.
#+end_info
* Problems
  No optional problems this week.
** DONE SUF
   CLOSED: [2019-03-07 Thu 10:50]
#+begin_note
  How would you write (using map /not/ a loop) an elisp function
  =number-of-factors= that takes the CSF of a positive integer (in
  list-of-dotted-pairs form) and returns how many factors that integer has?

#+BEGIN_SRC elisp
  (defun number-of-factors (csf)
    "Takes a CSF like '((2 . 3) (3 . 1) (5 . 2)) and returns 24."
    ;; ... your ONE line of code goes here
    )
#+END_SRC
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
#+BEGIN_SRC elisp :results silent
  (defun number-of-factors (csf)
  "Takes a CSF like '((2 . 3) (3 . 1) (5 . 2)) and returns 24."
  ;(mapcar 'car csf))
  ;(apply '* (mapcar '1+ (mapcar 'cdr csf)))
  (apply '* (mapcar (lambda (pair) (1+ (cdr pair))) csf)) 

  ;; ... your ONE line of code goes here
  )
#+END_SRC
#+BEGIN_SRC elisp
  (number-of-factors '((2 . 3) (3 . 1) (5 . 2)))
#+END_SRC

#+RESULTS:
: 24

** TODO LNR
#+begin_note
  How would you write (using map /not/ a loop) another elisp function
  =number-of-factors-alt= that takes the CSF of a positive integer (in
  vector-of-two-element-lists form) and returns how many factors that integer
  has?

#+BEGIN_SRC elisp
  (defun number-of-factors-alt (csf)
    "Takes a CSF like [(2 3) (3 1) (5 2)] and returns 24."
    ;; ... your ONE line of code goes here
    )
#+END_SRC
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO LDO
#+begin_note
  Investigate what must happen to delete a key from a BST. Is deletion always as
  fast as insertion?
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO YCF
#+begin_note
  Compare and contrast the different nuances in the precise definitions of the
  terms *full*, *complete* and *balanced* used to describe trees.
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** TODO YZU
#+begin_note
  Investigate various techniques to rebuild unbalanced BSTs to make them
  balanced. Note that this rebuilding can happen on-the-fly (as items are
  inserted) or at-the-end (after all initial items are inserted).
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
* Puzzles
  No puzzles this week.
