#+TITLE:CS 237 Syllabus and Portfolio@@html:<br>@@ Winter 2019
#+LANGUAGE: en
#+OPTIONS: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t ':t
#+OPTIONS: html-postamble:nil
#+STARTUP: showeverything entitiespretty

* What\rsquo{}s It All About?                                             :noexport:
  This course is about *mathematics for computer science.* 

  It introduces the mathematical topics needed to provide a solid theoretical 
  foundation for your career and continued learning in computer science. 

  The following topics will be covered:

  + Sets and Logic
  + Functions and Relations
  + Combinatorics and Probability
  + Number Theory and Practice
  + Trees and Graphs
  + Languages and Grammars

  In other words, it\rsquo{}s a blast!

* Objectives                                                       :noexport:
+ Master the basic terminology and operations of sets and logic, functions and
  relations, combinatorics and probability, number theory and practice, trees
  and graphs, and languages and grammars.
+ Demonstrate logical reasoning as you solve interesting problems.
+ Interpret the meaning of mathematical statements in the context of
  applications in computer science.
+ Think like a mathematician by making good connections.
+ Learn basic functional programming through using, reading, and writing elisp
  code.

* Prerequisites                                                    :noexport:
+ You must have successfully completed CS 165, Object-Oriented Software Development.
+ You must also have developed an awareness of what logical thinking entails. 

* Requirements                                                     :noexport:
You are required to
+ attend class each class period (but then again, why wouldn\rsquo{}t you?),
+ read assigned portions of the course materials /before/ the class meeting when they will be discussed,
+ complete weekly preparation assessments, and 
+ do weekly homework assignments to deepen your understanding of selected topics.

* Text                                                             :noexport:
+ [[https://rickneff.github.io/metaphors-be-with-you.html][Metaphors Be With You]]

* Software                                                         :noexport:
  (For the first two, see installation instructions [[https://rickneff.github.io][here]] and go to the /Tools/
  section. For the third, more information will be given later.)
+ git 
+ Spacemacs/Emacs
+ @@latex:\LaTeX{}@@ 

* Behavioral Requirements                                          :noexport:
You are required to\dots{}
+ attend class, as assessments will happen in class each day that are not reproducible outside of class.
+ read assigned portions of the course materials /before/ class each Tuesday and Thursday.
+ complete all team and personal assessments to deepen your understanding of selected topics.
+ acquire and maintain a three-ring binder that will hold your portfolio of completed work (see below).

* Course Periodicity                                               :noexport:
This course has a weekly period, i.e., you can count on knowing ahead of time
what you will be doing each day of each week. Each class period consists of two
30-minute sections.

On Tuesdays these sections are:

 - Presentation :: --- A time where I will add depth information to the preparation
                   material you finished reading *before class*.
 - Class Directed Learning :: --- You will participate in a class-wide activity that
      reinforces what you\rsquo{}ve read and what I\rsquo{}ve shown you.

On Thursdays these sections are:
 - Answer Questions :: --- I will answer questions that have been submitted to the
      class slack channel (more on which later).
 - Class Directed Learning :: --- You will participate in a class-wide activity that
      reinforces what you\rsquo{}ve read and what I\rsquo{}ve shown you.

* Questions                                                        :noexport:
+ The questions answered on Thursday are generalized from those you submit via
  the slack channel on Tuesday Evenings.
+ You must submit any and all unanswered questions on Tuesday evening. Not
  submitting questions leads to a reduced learning experience.
+ You will have plenty of questions. Submit them! Choose knowledge over ignorance.

* Exercises                                                        :noexport:
Exercises are smaller experiences that are designed to float uncertainties and
questions you have to the surface of your mind. They are designed to be smaller
so you can find out what you don\rsquo{}t know and then take the steps necessary to
know.

* Problems                                                         :noexport:
Problems are weightier experiences that invite you to explore topics in discrete
mathematics, as well as increase your logical thinking and problem solving
prowess. All involve writing mathematically.

* Assessment                                                       :noexport:
Every four weeks you will meet with me in my office. The purpose
of this meeting is for you to present your portfolio of work to me, make a
grade-to-date claim, and provide evidence justifying that claim.

Your portfolio *MUST* be a modified version of this file. All entries must
follow the example format you will find at the end of this document (when it is
updated). Also, your evidences must be complete and internally consistent. You
are required to produce the portfolio using Spacemacs, export it as a pdf file,
and print it. To accmoplish this you will need @@latex:\LaTeX{}@@ installed on
your machine.

* Late Work                                                        :noexport:
Late work is accepted /only if/ the reason is extraordinary, and acceptance is
reached through private and prolonged negotiation. Also, you must come talk to
me in person in my office --- *NOT* by email, nor any other means of
communication.

* Grades                                                           :noexport:
In each of our three personal meetings, you will present your portfolio and a
letter-based grade-to-date claim. Afterwards I will give you my thoughts on the
strength of your claim. The last claim that you make, taking into account any
feedback from me, will be your final grade for the course. All of your claims
must must be evidence-based. That means you *MUST* bring the evidence with you,
in your portfolio, that supports your claim.

** Letter-Based
When making your claim, you are required to use the [[http://www.byui.edu/student-records/grades/grading-system][BYU-Idaho standard]]
letter-based definition of grades, reproduced below:

+ \ldquo{}A\rdquo represents outstanding understanding, application, and integration of
  subject material and extensive evidence of original thinking, skillful use of
  concepts, and ability to analyze and solve complex problems. Demonstrates
  diligent application of Learning Model principles, including initiative in
  serving other students.
+ \ldquo{}B\rdquo represents considerable/significant understanding, application, and
  incorporation of the material that would prepare a student to be successful in
  next level courses, graduate school, or employment. The student participates
  in the Learning Model as applied in the course.
+ \ldquo{}C\rdquo represents sufficient understanding of subject matter. The student
  demonstrates minimal initiative to be prepared for class. Sequenced courses
  could be attempted, but mastering new materials might prove challenging. The
  student participates only marginally in the Learning Model.
+ \ldquo{}D\rdquo represents poor performance and initiative to learn and understand and
  apply course materials. Retaking a course or remediation may be necessary to
  prepare for additional instruction in this subject matter.
+ \ldquo{}F\rdquo represents failure in the course.

Note that the above description of an \ldquo{}A\rdquo implies that you have gone *above and
beyond*. To claim this grade you *must* have continually done the following
things throughout the 4-week period and recorded evidence of this behavior in
your portfolio. These behaviors are:
  1. teaching and/or helping others in the class but not in your group;
  2. teaching a Non-CS, Non-CE, Non-EE, Non-SE major about the material in this
     class to help them with a class they are taking;
  3. applying what you've learned in this class in another class you are
     currently taking; and
  4. doing work not assigned such as exploring mathematics, writing code
     implementing what you are learning that has not been assigned, etc.

Regarding the first two, quoting Truman Madsen (quoting the Prophet Joseph
Smith): Now one of the strongest and wisest statements I have ever heard on
egoism. The question was put to him, \ldquo{}Joseph, is the principle of
self-aggrandizement wrong? Should we seek our own good?\rdquo Listen to his answer.
\ldquo{}It is a correct principle and may be indulged upon only one rule or plan ---
and that is to elevate, benefit, and bless others first. If you will elevate
others, the very work itself will exalt you. Upon no other plan can a man justly
and permanently aggrandize himself.\rdquo
* Harassment                                                       :noexport:
	Title IX of the Education Amendments of 1972 prohibits sex discrimination
  against any participant in an education program or activity that receives
  federal funds, including Federal loans and grants. Title IX also covers
  student-to-student sexual harassment. If you encounter unlawful sexual
  harassment or gender based discrimination, please contact the Personnel Office
  at 496-1130.

* Disability                                                       :noexport:
  Brigham Young University-Idaho is committed to providing a working and
  learning atmosphere which reasonably accommodates qualified persons with
  disabilities. If you have any disability which may impair your ability to
  complete this course successfully, please contact the Services for Students
  with Disabilities Office, 496-1158. Reasonable academic accommodations are
  reviewed for all students who have qualified documented disabilities. Services
  are coordinated with the student and instructor by this office. If you need
  assistance or if you feel you have been unlawfully discriminated against on
  the basis of disability, you may seek resolution through established grievance
  policy and procedures. You should contact the Personnel Office at 496-1130.

* Readings                                                         :noexport:
  These readings are to be completed *prior to* each listed week\rsquo{}s Tuesday class.
  The listed Exercises/Problems/Puzzles (EPPs) for each week are to be completed
  *prior to* midnight each Friday. (More details about these EPPs will be
  available in each week\rsquo{}s course files.)

  | Week | Reading | Exercises/Problems/Puzzles (EPPs)       |
  |------+---------+-----------------------------------------|
  |   01 | <ABC    | CRC DGZ CHJ DOK CJF DZB                 |
  |   02 | ABC     | OQP USV UCA ODS UGX OGR UWM OPZ UOX OTX |
  |      |         | UOT OIM UIN OJL UCG OIO UIJ OQT UTQ OYU |
  |      |         | UOH OZD UZM OOY UFZ OKJ UVH OJM ULQ OTD |
  |      |         | UJU OLH UWY OBW USL OYP UBV OKQ UKF OKL |
  |      |         | UEZ OYW UEF OUB UQY                     |
  |   03 | DEF     | TBD WDK TDR WDT TEH WFC TEJ WFK TER WGP |
  |      |         | TEU WGW TFV WJS TGE WKC THP WKM TIW WNW |
  |      |         | TKG WOV TME WQW TMZ WRA TNL WRD TNQ WRP |
  |      |         | TOJ WRU TOL WZO TOU WYH TLI WPI TSD WTM |
  |      |         | TTV WUZ WZM TUK WVQ TUQ WVU TUW WWD TVL |
  |      |         | WWR TWN WWS TXG WZG TKH WUE             |
  |   04 | GHI     | EBQ MGX ECI MHB ECT MKJ EFE MKL EFS MLB |
  |      |         | EJE MLU EJK MMC EJU MNE EKQ MON         |
  |   05 | JKL     | QAM REX QCV RFC QCZ RFF QDM RGL QEB RGM |
  |      |         | QFK RHB QGK RVB QGT RJV QIQ RLH QKA RNC |
  |      |         | QKT RNM QOS ROP QRQ ROX                 |
  |   06 | MNO     | FAB ISM FBH ITT FDK IVO FDZ IWC FJH IWK |
  |      |         | FJY IXT FMD IYJ FOJ IZL FOY VAO FQI VAR |
  |      |         | FQL VAY FQW VCR FRM VEM FUA VFJ FVF VGU |
  |      |         | FVH VGX FXI VIB FYR VIW                 |
  |   07 | PQR     | GMQ JPZ GMY JQA GRZ JYA GXF XAJ GYI XFO |
  |   08 |         | GYN XGG                                 |
  |   09 | STU     | LDA SQI LJP SUF LNR YGT LDO YCF LUM YZU |
  |   10 |         | LTI YDQ LND YTR LGO YIV                 |
  |   11 | VWX     | HST KDB HTC KPS ABR KWD HRR KEO HMO HIJ |
  |   12 |         | KLE HAB KOV HBT AGA KNF HJS HAX KHQ HKE |
  |      |         | KBB HRL AGD HSG KHO ANA HLX KSI HTR KSQ |
  |      |         | HBE KSC                                 |
  |   13 | YZ@     | BAO NCO PDQ NTC PTW NTM PMV NES BRZ BRE |
  |      |         | NGP BRQ PIQ PRK NIO PFA BGT NGI NLR BSP |
  |      |         | NBO PBI BJO NKY BMI                     |

#+Begin_Latex
\pagebreak
#+End_Latex

* Portfolio
** Course Tracker
   You are required to track your progress in the course using this table. 

   Note: Currently, you see full credit for week one\rsquo{}s work. (\checkmark means yes. Blank
   means no.) Update the table for week 2 and all subsequent weeks each class
   day and week during the semester.

| / |   <> | <>  | <>  | <>  | <>  | <>  | <>  |   <> |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # | Week | CRU | PFP | CDL | SAQ | PAQ | CDL |  PPL |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    1 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    2 | \check   | *   | *   | *   | \check   | \check   |  90% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    3 | \check   | \check   | \check   | \check   | \check   | \check   |  75% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    4 | \check   | \check   | \check   | \check   | \check   | \check   |  80% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    5 | \check   | \check   | \check   | \check   | *   | *   |  90% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    6 | \check   | \check   | \check   | \check   | \check   | \check   |  70% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    7 | \check   | \check   | \check   | \check   | \check   | \check   |  90% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    8 | \check   | \check   | \check   | \check   | \check   | \check   | *80% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |    9 | \check   | \check   | \check   | \check   | \check   | \check   | 100% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |   10 | \check   | \check   | \check   | \check   | \check   | \check   |  95% |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |   11 | \check   | \check   | \check  | \check    | \check   | \check  | 100%   |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |   12 | \check  | \check   |     |     |     |     |      |
|---+------+-----+-----+-----+-----+-----+-----+------|
| # |   13 |     |     |     |     |     |     |      |
|---+------+-----+-----+-----+-----+-----+-----+------|

This is an honest and true record of my work for this course.

#+Begin_Latex
\vspace{1in}
#+End_Latex

Signature: @@latex:\underline{\makebox[4in]{}}@@

** Acronym Key
   Course Tracker acronyms and their meanings.

	+ CRU - I Completed the Reading and achieved a level of Understanding *before*
    the start of Tuesday\rsquo{}s class and recorded questions about the items I didn\rsquo{}t
    understand.
	+ PFP - I was present for and attentive to the presentation for this date.
	+ CDL - I fully participated in the Class Directed Learning for this date.
	+ SAQ - I submitted /at least 1/ appropriate, Significant, Actual Question I
    have regarding the information for this week.
	+ PAQ - I was Present for and Attentive to the Answer Questions presentation
    for this date.
	+ PPL - I, individually, correctly completed this Percentage of the Problems
    and exercises proving this Level of understanding before Friday at Midnight.

* Grade Claims

On the week indicated, bring this updated document to my office and make your claim.

| / | <>         | <>          | <>               | <>             |
|---+------------+-------------+------------------+----------------|
| # | Claim Week | Grade Claim | Instructor Grade | Adjusted Grade |
|---+------------+-------------+------------------+----------------|
| # | 5          |  B          |  B               |  B             |
|---+------------+-------------+------------------+----------------|
| # | 9          |  B          |  B               |  B             |
|---+------------+-------------+------------------+----------------|
| # | 13 - 14    |             |                  |                |
|---+------------+-------------+------------------+----------------|


#+Begin_Latex
\pagebreak
#+End_Latex

* Evidences
  
  Fill in your evidences here each week to build your portfolio. The number of
  pieces of evidence are determined by you. However, the more you have the
  better off you will be.

** Week 1

** DONE DGZ
   CLOSED: [2019-01-31 Thu 10:38]
#+begin_note
  The operation called /dehydration/ takes a word and deletes all letters in it
  from H to O. What is the original (rehydrated) text of this dehydrated
  sequence of words?

  TE TE AS CE TE WARUS SAD T TA OF AY TGS F SES AD SPS AD SEAG WAX F CABBAGES
  AD GS AD WY TE SEA S BG T AD WETER PGS AVE WGS
#+end_note
#+begin_info
  Interestingly enough, after looking at two distinct dehydrated words, “WARUS” and “CABBAGES”,
  I recalled a memory of my grade school years at charter school.  We were required to memorize 
  multiple poems throughout the school year.  I knew this was from some sort of poem, so I searched
  “walrus cabbage poem” and bam.  Stanza 65 from Lewis Carroll’s “Alice in Wonderland” which says 
  “The time has come,” the Walrus said, “To talk of many things: Of shoes—and ships—and sealing-wax
  Of cabbages—and kings—And why the sea is boiling hot—And whether pigs have wings.”
#+end_info
*** Some Other Exercise or Problem
#+begin_note
  Let $n / 0$ be infinity, for any positive integer /n/.

  What English word has the largest /finite/ consonant-vowel-ratio (CVR)? For
  example, the CVRs of the words (including the TLA) in the previous sentence
  are 3:1, 5:2, 3:1, 2:1, 2:1, 5:2, 1:1, 2:1, 3:2, 2:3, and infinity (3:0).
#+end_note
#+begin_info
  I was trying to think of words with few syllables, because typically there are multiple vowels when 
  there are multiple syllables.  Then I searched single-syllable words with the most consonants, and I 
  found the word “strengths”, which has 8:1 consonant to vowel ratio.
#+end_info

*** Some Problem Requiring Code
** DONE DZB
   CLOSED: [2019-01-31 Thu 10:38]
#+begin_note
  In the figure below, the innermost circle has radius 1. It is circumscribed by
  an equilateral triangle, which is circumscribed by a circle, which is
  circumscribed by a square, which is circumscribed by yet another circle, and
  so forth.

  [[file:../img/circumscribed-polygons-and-circles.png][file:../img/circumscribed-polygons-and-circles.png]]

  What is the radius of the outermost circle?
#+end_note
#+begin_info
  I used excel to compute the circle.  I created a somewhat infinite series based upon
  the ratio of around 0.82, which I figured out by calculating the first three circle radiuses.
  I then used that ratio to compute the diameter as the change approached zero, which was around 6.55.
#+end_info
** Week 2
#+CAPTION: Clock summary at [2019-01-18 Fri 10:43]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *8:00* |
#+END:
** DONE UCG
   CLOSED: [2019-01-17 Thu 16:43]
#+begin_note
  Let set *A* = =[verve vim vigor]=, set *B* = =[butter vinegar pepper vigor]=.
  For each of the following set operations, give its resulting members (as a
  vector of symbols):

  1. The set of words that are in A *or* B; call this set *C*.
  2. The set of words that are in A *and* B; call this set *D*.
  3. The subset of set *C* of words that start with \lsquo{}v\rsquo.
  4. The subset of set *C* of words that end with \lsquo{}r\rsquo.
  5. The subset of set *C* of words that start with \lsquo{}v\rsquo and end with \lsquo{}r\rsquo.
  6. The subset of set *D* of words that have six letters.
:HINT:
  - Hint :: This is also very straightforward. But see if you can write some
            elisp code to help you find the answers!
:END:
#+end_note
#+begin_info
  1. C = [verve vim vigor butter vinegar pepper] 
  2. D = [vigor]
  3. C(subset) = [verve vim vigor vinegar]
  4. C(subset) = [vigor butter vinegar pepper]
  5. C(subset) = [vigor vinegar]
  6. D(subset) = [] ;; empty
#+end_info

** DONE UIN
   CLOSED: [2019-01-17 Thu 16:13]
#+begin_note
  What is the set difference between the set of letters in the English alphabet
  and the set of letters in the Hawaiian alphabet?
#+end_note
#+BEGIN_SRC emacs-lisp
;;I will use sets to see the difference.  I googled the Hawaiian alphabet.
(require 'cl)
(set-difference '(a b c d e f g h i j k l m n o p q r s t u v w x y z) '(a e i o u h k l m n p w))
#+END_SRC

#+RESULTS:
| b | c | d | f | g | j | q | r | s | t | v | x | y | z |

** DONE UTQ
   CLOSED: [2019-01-17 Thu 17:19]
#+begin_note
  Let /p/ and /q/ be the propositions:

  /p/: You applied for admission at BYU-Idaho.

  /q/: You were accepted.

  Express these sentences as propositions using logical connectives.
  1. You applied for admission at BYU-Idaho and were accepted.
  2. You did not apply for admission at BYU-Idaho but were still accepted.
  3. You applied for admission at BYU-Idaho but were not accepted.
  4. Either you did not apply for admission at BYU-Idaho and didn\rsquo{}t get accepted
     or you did apply and got accepted.
#+end_note
#+begin_info
  1. p ^ q
  2. \not p ^ q
  3. p ^ \not q
  4. (\not p ^ \not q) v (p ^ q)
#+end_info

** DONE UIJ
   CLOSED: [2019-01-17 Thu 16:42]
#+begin_note
  The following Venn diagram numbers three regions of a set B with a subset A
  relationship within a Universal set U:

#+BEGIN_SRC ditaa :file img/fig-set-subset-conditional.png :cmdline -S :export :eval no-export
  U                       1
    +-------------------+
    | B               2 |
    |   +-----------+   |
    |   | A       3 |   |
    |   |           |   |
    |   |           |   |
    |   +-----------+   |
    |                   |
    +-------------------+
#+END_SRC

#+RESULTS:
[[file:img/fig-set-subset-conditional.png]]

  Make a connection between the logical conditional operator (\rightarrow) and the
  /definition/ of a subset. Refer to the three numbered regions in your answer.
:HINT:
  - Hint :: Making this connection means: 1) express the logical conditional
            operator in terms of the definition of subset, or 2) express subset
            in terms of the definition of the logical conditional operator,
            whichever makes the most sense to you. Express either (or both) in
            terms of the three numbered regions.

  - More Emphatically :: Making this connection will help you understand why the
       conditional operator works the way it does. To answer fully, you /must/
       give the definition of a subset, and you /must/ refer to the three
       numbered regions in the Venn diagram.
:END:
#+end_note
#+begin_info
  The symbol -> means that if the thing on the thing on the left is true, the thing on the right
  is also true.  That means that is U is true, 1 is true.  Becuase B is a subset of U, B is true as
  well making 2 true.  A is a subset of B, so A is true if B is true, making 3 true as well.  That means
  A -> B -> U.
#+end_info

** DONE UZM
   CLOSED: [2019-01-17 Thu 16:54]
#+begin_note
  Determine whether these biconditionals are true or false:
  1. 2 + 1 = 3 if and only if 1 + 2 = 3.
  2. 1 + 2 = 3 if and only if 3 + 1 = 6.
  3. 1 + 3 = 2 if and only if the earth is flat.
  4. 1 < 2 if and only if 2 < 3.
#+end_note
#+begin_info
  1. true.
  2. false.
  3. false.
  4. true.
#+end_info

** Week 3
#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2019-01-25 Fri 16:54]
| Headline     | Time    |
|--------------+---------|
| *Total time* | *12:25* |
#+END:
** DONE TEJ
   CLOSED: [2019-01-24 Thu 13:24]
#+begin_note
  A function-as-association between elements of a domain and elements of a
  codomain, for \ldquo{}small\rdquo domains and codomains, inspired so-called \ldquo{}association
  lists\rdquo (or alists) and the =assoc= (and associated) functions.

  =(assoc KEY LIST)= returns non-nil if KEY is \ldquo{}equal\rdquo to the first element of
  an element of LIST. The value is actually the first element of LIST whose
  first element equals KEY.

  For example, here is a function that uses an alist to look up the RGB values
  of a given color name:

#+BEGIN_SRC emacs-lisp :results silent
  (defun lookup-rgb (color-name)
    (rest (assoc color-name
                 '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
  (lookup-rgb "blue")
#+END_SRC

: (0 0 255)

  What if the color name is not in the alist?

#+BEGIN_SRC emacs-lisp :results raw
  (lookup-rgb "grue")
#+END_SRC

: nil

  There are several variations of =assoc=. Find and give examples of using them.
#+end_note
#+BEGIN_SRC emacs-lisp
  (defun lookup-rgb (color-name)
    (rest (assoc-string color-name
                 '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))))
  (lookup-rgb "blue")
#+END_SRC

#+RESULTS:
| 0 | 0 | 255 |
For assoc-string, the key should be a string.

#+BEGIN_SRC emacs-lisp
  (defun lookup-rgb (color-name)
    (rest (rassoc color-name
                 '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))))
  (lookup-rgb '(255 0 0))
#+END_SRC

#+RESULTS:
| 255 | 0 | 0 |
For rassoc, you use the results to look up the item. It's like a reverse assoc

#+BEGIN_SRC emacs-lisp
  (defun lookup-rgb (color-name)
    (rest (assq color-name
                 '((red 255 0 0) (green 0 255 0) (blue 0 0 255)))))
  (lookup-rgb 'blue)
#+END_SRC

#+RESULTS:
| 0 | 0 | 255 |
Very simmilar to assoc. You don't need quotes arond the names and just a quote on what you are looking up.
#+END_SRC

** DONE WKM
   CLOSED: [2019-01-24 Thu 13:53]
#+begin_note
  Which of these statements about floor and ceiling are correct, for any real
  number $x$ and any integers $n$ and $m$?
  1. $x - 1 < \lfloor{}x\rfloor \le x \le \lceil{}x\rceil < x + 1$.
  2. $\lfloor{}-x\rfloor = -\lceil{}x\rceil$.
  3. $\lceil{}-x\rceil = -\lfloor{}x\rfloor$.
  4. $\lfloor{}x + n\rfloor = \lfloor{}x\rfloor + n$.
  5. $\lceil{}x + n\rceil = \lceil{}x\rceil + n$.
  6. $\lfloor{}\frac{n}{2}\rfloor + \lceil{}\frac{n}{2}\rceil = n$.
  7. $\lfloor{}\frac{n}{2}\rfloor + \lfloor{}\frac{n + 1}{2}\rfloor = n$.
  8. $\lceil{}\frac{n}{2}\rceil + \lceil{}\frac{n + 1}{2}\rceil = n$.
  9. $\lfloor{}\frac{n + m}{2}\rfloor + \lceil{}\frac{n - m + 1}{2}\rceil = n$ (for any $m$, not just $m =
     0$ as in statement 7).
  10. $\lceil{}\frac{n + m}{2}\rceil + \lceil{}\frac{n - m + 1}{2}\rceil = n$ (for any $m$, not just $m =
      0$ as in statement 8).
#+end_note
#+begin_info
  1. true
  2. true
  3. false
  4. true
  5. true
  6. true
  7. true
  8. false
  9. true
  10. true
#+end_info

** DONE TOL
   CLOSED: [2019-01-24 Thu 15:08]
#+begin_note
  Translate these statements into English, where S(x) is \ldquo{}x is a student\rdquo, R(x)
  is \ldquo{}x is from Russia\rdquo, and the domain consists of all people.
  1. $\forall$ x (S(x) $\rightarrow$ R(x))
  2. $\exists$ x (R(x) $\rightarrow$ R(x))
  3. $\forall$ x (S(x) $\wedge$ R(x))
  4. $\exists$ x (S(x) $\wedge$ R(x))
#+end_note
#+begin_info
  1. Every student is from Russia.
  2. There exists a student that is from Russia.
  3. Every person is a student and is from Russia.
  4. There exists a person that is a student and is from Russia.
#+end_info

** DONE TUQ
   CLOSED: [2019-01-24 Thu 15:55]
#+begin_note
  Take the statement Q(x, y) \ldquo{}x asks y a question\rdquo. Express each of these
  sentences in terms of Q(x, y), quantifiers, and logical connectives, where the
  domain for x consists of people at your school, and likewise for y consists of
  people at your school. Use the predicates S(x) = \ldquo{}x is a student\rdquo, T(x) = \ldquo{}x
  is a teacher\rdquo, and A(x) = \ldquo{}x is a TA\rdquo to distinguish different roles for
  people.
  1. No student has ever asked a teacher a question.
  2. There is a student who has asked a teacher a question.
  3. Every student has asked a teacher and a TA a question.
  4. At least two students have asked a teacher a question.
#+end_note
#+begin_info
  1. \not \forall x \forall y Q(S(x),T(y))
  2. \exist x \exist y Q(S(x),T(y))
  3. \forall{}x S(x) \exist{}y T(y) \land \exist{}z A(z), Q(x, y) \land Q(x, z)
  4. \exist x S(x) \exists{}y S(y) \exist{}z T(z), Q(x, z) \land Q(y, z)`
#+end_info

** DONE WFC
   CLOSED: [2019-01-24 Thu 16:29]
#+begin_note
  Remembering that these are functions, do the four basic math operators (=+=,
  =-=, =*=, =/=) work as you might expect?

  How about when the number of operands
  - is greater than two?
  - is less than two (i.e., one or zero)?

  This is a good time to mention that functions with arity /n/ for /n/ = 1
  (unary) and /n/ = 2 (binary) have alternate type names, as does a generic
  classification for /n/ > 2:

  | Arity | Type     |
  |-------+----------|
  |     1 | Monadic  |
  |     2 | Dyadic   |
  |   > 2 | Polyadic |

  Argue for /polyadic/ to mean having /arbitrary arity/ (taking 0 /or more/
  arguments).
#+end_note
#+begin_info
  I am familliar with prefix equations, so it works as expected.  If you use multiple operands,
  you have to use parenthesis
#+end_info
#+BEGIN_SRC elisp
  (+ 3(* 2 3))
#+END_SRC

#+RESULTS:
: 9

** DONE WKC
   CLOSED: [2019-01-24 Thu 16:43]
#+begin_note
  Define the \ldquo{}take the fractional part of\rdquo function =frac-part= in terms of
  =floor= as follows:

#+BEGIN_SRC emacs-lisp :results silent
  (defun frac-part (number)
    (- number (floor number)))
#+END_SRC

  For example,
#+BEGIN_SRC emacs-lisp
  (frac-part 3.14159)
#+END_SRC

: 0.14158999999999988

  Suppose =frac-part= were the primitive, built-in function. How would you
  define =floor= (assuming it were /not/ built-in) using =frac-part=?
#+end_note
#+begin_info
  Frac part would return only the fraction part of the number.  If frac-part != 0, you would 
  subtract fract-part.
#+end_info

** DONE TNQ
   CLOSED: [2019-01-25 Fri 15:45]
#+begin_note
  Consider the following function:

#+BEGIN_SRC emacs-lisp
  (defun calculate-pi-very-slowly (max-iterations)
    (* 4 (loop for n from 0 to max-iterations
               sum (/ 1.0 (* (+ (* 2 n) 1) (expt -1 n))))))

(calculate-pi-very-slowly 10000)
#+END_SRC

#+RESULTS:
: 3.1416926435905346

  How slow is \ldquo{}very slowly\rdquo?
#+end_note
#+begin_info
  The more loops the program goes through, the more precise pi becomes.  That means that if you
  want the most precision, you must run the loop that many times.  For infinite precision,
  you would have to loop through infinite times, taking infinite time!  Super slow!
#+end_info

** DONE WUE
   CLOSED: [2019-02-05 Tue 16:53]
#+begin_note
  Consider Doctrine and Covenants 130:20-21 in light of what you know of
  predicates and quantifiers:

  - 20. :: /There is a law, irrevocably decreed in heaven before the foundations
           of this world, upon which all blessings are predicated./
  - 21. :: /And when we obtain any blessing from God, it is by obedience to that
           law upon which it is predicated./

  Given the predicate $P(x, y)$ = \ldquo{}blessing $x$ is predicated on law \(y\)\rdquo,
  these two verses are best expressed as a quantified statement by which of the
  following?

  1. $\forall\,x\,\forall\,y\,P(x, y)$
  2. $\forall\,x\,\exists\,y\,P(x, y)$
  3. $\exists\,x\,\forall\,y\,P(x, y)$
  4. $\exists\,x\,\exists\,y\,P(x, y)$

  Justify your choice.
#+end_note
#+begin_info
  I would say 4, becuase even though it says "any blessing", each blessing is dependant 
  upon each of God's laws we follow.`
#+end_info
** Week 4
#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2019-01-31 Thu 16:24]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *6:00* |
#+END: 
** DONE ECI
   CLOSED: [2019-01-29 Tue 16:31]
#+begin_note
  Implement the =for-some-for-some=, =for-some-for-all=, and =for-all-for-some=
  functions in a similar manner to the mapping =for-all-for-all=. Test them with
  at least three different predicates and their associated domains.
:HINT:
  - Hint :: See MGX for the context. If there is an =every= for universal
            quantification, what might be its existential counterpart function?
:END:
#+end_note
#+begin_info
  Your answer goes here.

#+BEGIN_SRC elisp :results silent
  (defun map-for-some (pred x domain-y)
    (some (lambda (y) (funcall pred x y)) domain-y))
#+END_SRC

#+BEGIN_SRC elisp :results silent
  (defun map-for-all-for-some (pred domain-x domain-y)
    (every (lambda (x) (map-for-some pred x domain-y)) domain-x))
#+END_SRC

#+BEGIN_SRC elisp :results silent
  (defun map-for-some-for-all (pred domain-x domain-y)
    (some (lambda (x) (map-for-all pred x domain-y)) domain-x))
#+END_SRC

#+BEGIN_SRC elisp :results silent
  (defun map-for-some-for-some (pred domain-x domain-y)
    (some (lambda (x) (map-for-some pred x domain-y)) domain-x))
#+END_SRC
#+end_info
#+BEGIN_SRC elisp
  (list 

  (map-for-all-for-some '< [1 2 5] [1 5 5])
 
  (map-for-some-for-all '< [1 6 3] [4 5 6])

  (map-for-some-for-some '< [1 8 3] [4 1 6]))

#+END_SRC

#+RESULTS:
| nil | t | t |

** DONE MKJ
   CLOSED: [2019-01-29 Tue 16:46]
#+begin_note
  What is the most correct description of relation types for the relation
  on the set [1 2 3] given as the pairs heading the first column?
  | [(1 1) (1 3) (2 2) (3 1)] | Yes or No? |
  |---------------------------+------------|
  | Reflexive?                |    no      |
  | Symmetric?                |    yes     |
  | Antisymmetric?            |    no      |
  | Transitive?               |    no      |
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** DONE EFE
   CLOSED: [2019-01-29 Tue 16:52]
#+begin_note
  What is the most correct description of relation types for the relation
  on the set [1 2 3] given as the pairs heading the first column?
  | [(1 1) (2 2) (3 1) (3 3)] | Yes or No? |
  |---------------------------+------------|
  | Reflexive?                | yes        |
  | Symmetric?                | no         |
  | Antisymmetric?            | no         |
  | Transitive?               | no         |
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** DONE MKL
   CLOSED: [2019-01-29 Tue 16:48]
#+begin_note
  What is the most correct description of relation types for the relation
  on the set [1 2 3] given as the pairs heading the first column?
  | [(1 2) (2 1) (3 3)] | Yes or No? |
  |---------------------+------------|
  | Reflexive?          |    no      |
  | Symmetric?          |    yes     |
  | Antisymmetric?      |    no      |
  | Transitive?         |    no      |
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** DONE EFS
   CLOSED: [2019-01-29 Tue 16:49]
#+begin_note
  What is the most correct description of relation types for the relation
  on the set [1 2 3] given as the pairs heading the first column?
  | [(1 3) (2 3)]  | Yes or No? |
  |----------------+------------|
  | Reflexive?     |   no       |
  | Symmetric?     |   no       |
  | Antisymmetric? |   yes      |
  | Transitive?    |   no       |
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info

** DONE MHB
   CLOSED: [2019-01-31 Thu 16:14]
#+begin_note
   From the definition of antisymmetric, show using logic that if xRy and x \ne y
   then it is false that yRx.
:HINT:
  - Hint :: The definition is a conditional, so use its contrapositive, which is
            equivalent.
:END:
#+end_note
#+begin_info
  If (xRy \land yRx then x = y), but if (xRy \land x \ne y, then yRx does not work)
  So, if x relates to y, and y relates to x, you can assume that x = y.  But, if
  x relates to y and x \ne y, then yRx does not hold. 
#+end_info

** DONE EKQ
   CLOSED: [2019-01-31 Thu 17:23]
#+begin_note
  Which of the following are equivalence relations? If it is, show it has
  reflexivity, symmetry and transitivity. If not, argue for which of these three
  properties it lacks. The first four have people for their domain, the last
  four have numbers for their domain:

  1. xRy if x and y are siblings.
  2. xRy if x and y have the same parents.
  3. xRy if x and y share a common parent.
  4. xRy if x and y speak a common language.
  5. With domain English words, xRy if x shares a vowel with y.
  6. xRy if x \le y.
  7. xRy if x^2 + y^2 = 1.
  8. xRy if x + y = 42.
  9. xRy if \lceil{}x\rceil = \lfloor{}y\rfloor.
:HINT:
  - Hint :: This is a straightforward exercise in applying the definitions of
            these properties, and doing some logical thinking.
:END:
#+end_note
#+begin_info
  1. No, it is not relexive because you are not your own sibling.
  2. Yes.  X has the same parents as itself, Y has the same parents as itself,
     and X and Y have the same parents as one another.
  3. No, it is not transitive.  Y could have a different parent than X with a sibling
     that has 2 different parents than X.  Therefore, xRy \land yRz, x \ne z.
  4. Same as above, not transitive.  If y knows a language that x doesn't, and knows z who speaks
     that language, xRy \land yRz, x \ne z
  5. No. Same reason as above
  6. No
  7. yes
  8. no, this could imply that x + x also equals 42 and y + y also equals 42, which is not true.
  9. yes
#+end_info
** EBQ ;Ask Brother Neff!

#+BEGIN_SRC elisp
   (defun cartesian-product-n (&rest l1)
(loop for set in l1
    
(loop for i across s1
        append (loop for j across s2
                     append (loop for k across s3
                                  collect (list i j k)))))

#+END_SRC;ask brother neff; Ask brother Neff
#+BEGIN_SRC elisp
  (defun loops-list (n num-lists)
    (if (= n num-lists)
        (apply 'list 'list (loop for i from 0 below n collect (make-item-symbol i )))
        (append (list 'loop 'for (make-item-symbol n ) 'in (list 'nth n 'lists)))
        
#+END_SRC
#+BEGIN_SRC elisp
(defun cartesian-product (a b) ; please help me understand this!  It took me a long time before I got here!
  (mapcan
    (lambda (item-a)
      (mapcar
        (lambda (item-b)
          (if (listp item-a)
            (append item-a (list item-b))
            (list item-a item-b)))
        b))
    a))


(reduce #'cartesian-product '((0 1) (0 1) (0 1) (0 1) (0 1)))
#+END_SRC

RESULTS:
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 |
| 0 | 0 | 0 | 1 | 0 |
| 0 | 0 | 0 | 1 | 1 |
| 0 | 0 | 1 | 0 | 0 |
| 0 | 0 | 1 | 0 | 1 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 0 | 1 | 1 | 1 |
| 0 | 1 | 0 | 0 | 0 |
| 0 | 1 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 0 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 0 | 1 | 1 | 1 | 0 |
| 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 0 | 1 | 1 |
| 1 | 0 | 1 | 0 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 1 | 1 |
| 1 | 1 | 0 | 0 | 0 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 | 1 |
| 1 | 1 | 1 | 0 | 0 |
| 1 | 1 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 | 0 |
| 1 | 1 | 1 | 1 | 1 |

** Week 5
#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2019-03-05 Tue 16:32]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *5:32* |
** DONE QAM
   CLOSED: [2019-02-12 Tue 09:58]
#+begin_note
  Henry only has one pair of pants. How many different outfits does Henry have
  if he has 5 long-sleeve shirts and 3 short-sleeve shirts? (An outfit is \ldquo{}pants
  with either a long-sleeve shirt or a short-sleeve shirt\rdquo.)

  If Henry buys another pair of pants and 10 ties, then how many different
  outfits (shirt /and/ tie /and/ pants) will he have?

  Which basic counting principle applies to each scenario?
:HINT:
  - Hint :: Avoid overthinking this exercise, it is very straightforward. In the
            first scenario, the either/or is a very obvious clue.
:END:
#+end_note
#+begin_info
  In the first scenario, he has 8 outfits.  In the second, he has 160 options.  The addition principle 
  
#+end_info
** REX
#+begin_note
  How should the /Sum Rule/ be adjusted when the two sets being selected from
  are /not/ disjoint --- which means the /opposite/ of the oft-repeated \ldquo{}the
  sets are disjoint\rdquo --- they have a /nonempty/ intersection; in other words,
  they have /some/ members in common.
:HINT:
  - Hint :: Concretize two sets and draw their Venn diagram to get some insights
            into this problem.
:END:
#+end_note
#+begin_info
  It should be changed to be the length of the entire set.
#+end_info
** DONE QCV
   CLOSED: [2019-02-12 Tue 15:51]
#+begin_note
  How many different /functions/ are there from a set with 3 elements to a set
  with 5 elements?
:HINT:
  - Hint :: It may be helpful to review the definition of a /function/.
:END:
#+end_note
#+begin_info
  Set A to n and B to m.  There are m^n functions in a -> b, therefore, there are 5^3 or 125 functions.
#+end_info
** RFC
#+begin_note
  How many different /one-to-one/ functions are there from a set with 3 elements
  to a set with 5 elements?
:HINT:
  - Hint :: It may be helpful to review the definition of a /one-to-one
            function/ (an /injection/).
:END:
#+end_note
#+begin_info
  A one to one function is m!/(m-n)!, so there are 6 functions.
#+end_info
** QCZ
#+begin_note
  How many different /onto/ functions are there from a set with 3 elements to a
  set with 5 elements?
:HINT:
  - Hint :: It may be helpful to review the definition of an /onto/ function/ (a
            /surjection/).
:END:
#+end_note
#+begin_info
  There are zero, becuase an onto function implies that every element of one set can be
  mapped to the other, therefore there are zero.
#+end_info
** DONE QDM
   CLOSED: [2019-02-12 Tue 15:58]
#+begin_note
  The English language predominantly uses the Subject-Verb-Object word type
  ordering; for example, \ldquo{}Gary saw Alice\rdquo. Other languages might use
  Subject-Object-Verb or Object-Verb-Subject, etc. How many different word
  orderings are possible, /not/ depending on specific words, just their type?
:HINT:
  - Hint :: This is a very straightforward exercise in permutations.
:END:
#+end_note
#+begin_info
There are 6 different orderings.
#+end_info
** RJV
#+begin_note
  Suppose you flip a /fair/ coin 10 times. How many different ways can you get

  1. no heads?
  2. exactly one head?
  3. exactly two heads?
  4. exactly $r$ heads?
  5. at least two heads?
#+end_note
#+begin_info
Use n! / (n-m)!m!
  1. 1
  2. 10
  3. 45
  4. 10! / (10-m)!m!
  5. 1013, encompassing exactly 2, 3, 4, 5, 6, 7, 8, 9, and 10.
#+end_info
** QIQ
#+begin_note
  How many bit strings of length 10 contain at least two 1s?
#+end_note
#+begin_info
  Same answer as above, 1013.
#+end_info
** RLH
#+begin_note
  There are many kinds of fruit: raspberries, strawberries, blueberries, apples,
  oranges, bananas, kiwi, papaya, mango, just to name a few. Just choosing five
  from that list of nine, how many different combinations of fruit salad can you
  make?
#+end_note
#+begin_info
  9!/(9-5)!5! = 126
#+end_info

** RGL
#+begin_note
  Recalling the example of how many are the permutations of the letters
  ABCDELMNO, investigate and explain why 0! is defined to be equal to 1.
#+end_note
#+begin_info
  n! = n*(n-1)!, therefore if 1! = 1, and 1!=1*1!, 0! also equals 1.
#+end_info
** QEB
#+begin_note
  How many of the 9! arrangements of the letters ABCDELMNO contain the string
  ELM?
:HINT:
  - Hint :: How many arrangements of ABCDENO are there?
:END:
#+end_note
#+begin_info
  P=n!/(n-r)!
  9!/(9-3)!
  504 
#+end_info
** RGM
#+begin_note
  How many TLAs (arrangements of 3 alphabetic letters) are there /with
  repetition allowed/?
#+end_note
#+begin_info
  This would be equal to the entire alphbet raisted to the power of 3 for three letter
#+end_info
#+BEGIN_SRC elisp
  (expt 26 3)
#+END_SRC

#+RESULTS:
: 17576

** QFK
#+begin_note
  How many different sequences of initials are there for people who either have
  two initials (first and last) or three initials (first, middle and last)?
#+end_note
#+begin_info
  simmilar to above.
#+end_info
#+BEGIN_SRC elisp
  (+ (expt 26 3) (expt 26 2))
#+END_SRC

#+RESULTS:
: 18252

** RHB
#+begin_note
  How many different sequences can be formed using /either/ two /or/ three
  letters (A-Z) followed by /either/ two /or/ three digits (0-9)?

  For example:

  - AB01
  - ABC02
  - XYZ123
  - ...
#+end_note
#+begin_info
#+end_info
#+BEGIN_SRC elisp
  (+ (+ (expt 26 2) (expt 10 2) (expt 10 3)) (+ (expt 26 3) (expt 10 2) (expt 10 3)))
#+END_SRC

#+RESULTS:
: 20452

** QGK
#+begin_note
  How many different \ldquo{}words\rdquo of the form =ccvcv= are there where =c= represents
  one of the 21 consonants and =v= represents one of the 5 vowels in the English
  alphabet? Assume no letter can be repeated, just count words like \ldquo{}tribe\rdquo or
  \ldquo{}blizo\rdquo --- a non-word but count it anyway --- but not something like \ldquo{}trite\rdquo
  or \ldquo{}gligi\rdquo, which have repeated letters.
#+end_note
#+begin_info
Non-repeating consonants is 20 * 19, times 6 vowels, 18 more consonants (so as to not repeat), then 6 vowels again.
#+end_info
#+BEGIN_SRC elisp
  (* (* 20 19) 18 (expt 5 2))

#+END_SRC

#+RESULTS:
: 171000

** QKT
#+begin_note
  When you roll two dice, what is the probability that the sum of the numbers
  (1-6) on their faces will be a multiple of 3 (3, 6, 9 or 12)?
#+end_note
#+begin_info
  There are 36 possible answers, and 4 possible others, so 4/36 = 1/9.
#+end_info
** RNM
#+begin_note
  Rather than roll dice, Ruth and Ed usually flip a coin to decide who's going
  to do the chores. One day Ed complains --- he thinks he loses too often. So
  Ruth says, \ldquo{}OK, this time you flip two coins, and I flip one. If you get more
  heads than I do, I\rsquo{}ll clean the toilets.\rdquo Ed likes Ruth\rsquo{}s display of
  generosity and says, \ldquo{}You\rsquo{}re on!\rdquo

  What are his chances?
:HINT:
  - Hint :: This was adapted from a problem posed by Marilyn Vos Savant in her
            \ldquo{}Ask Marilyn\rdquo Parade Magazine column.
:END:
#+end_note
#+begin_info
  His chances are exactly the same.  Because there is a 1/2 chance of getting heads, you add the 
  probability and divide it by the number of coins he is playing with.
#+end_info
#+BEGIN_SRC elisp
  (/ (+ 0.5 0.5) 2)
#+END_SRC

#+RESULTS:
: 0.5

** QOS
#+begin_note
  Generalize the two- and four- fair-coin-flipping experiment to deal with the
  experiment of flipping /2n/ coins. Find the probability of the event that /n/
  will be heads, and /n/ will be tails.
:HINT:
  - Hint :: The answer will be a function of /n/.
:END:
#+end_note
#+begin_info
  Each time, you do  1/n^2 to find the probability. 
#+end_info

** Week 6
#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2019-02-14 Thu 16:58]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *6:30* |
#+END:
** DONE FAB
   CLOSED: [2019-02-12 Tue 09:22]
#+begin_note
  There is a redundant word in the statement of the division theorem. What is
  it, and why is it redundant?
#+end_note
#+begin_info
  The word "positive" is not needed
#+end_info
** DONE FDZ
   CLOSED: [2019-02-14 Thu 15:39]
#+begin_note
  Re-implement =prime-power-list-to-number= without using =let= by instead
  putting everything =let= is doing within the =loop=.
:HINT:
  - Hint :: Use the =with= and =finally return= keywords.
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
#+BEGIN_SRC elisp :reults raw
 (defun prime-power-list-to-number (prime-power-list)
  (reduce #'* (loop with number = 1
        with primes = [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71]
        for prime across primes
        for power in prime-power-list
        collect (* number (expt prime power)))))
#+END_SRC

#+RESULTS:
: prime-power-list-to-number
#+BEGIN_SRC elisp
  (prime-power-list-to-number '(6 5 4 3 2 1))
#+END_SRC

#+RESULTS:
: 5244319080000

** DONE FJH
   CLOSED: [2019-02-14 Thu 15:43]
#+begin_note
  The FTA supports the mapping of the sequence =[2 0 0 0 0 1]= to a two-digit
  number. What is that number?
#+end_note
#+begin_info
  Just using mental math, this is (13*2) * 2 = 52
#+end_info
#+BEGIN_SRC elisp
   (prime-power-list-to-number '(2 0 0 0 0 1))
#+END_SRC

#+RESULTS:
: 52

** DONE IWK
   CLOSED: [2019-02-14 Thu 15:54]
#+begin_note
  A famous theorem states that there are infinitely many primes of the form
  /ak/ + /b/ whenever /a/ and /b/ are coprime. To get a feel for this, find for
  /a/ = 4 and /b/ = 11, ten different values for /k/ where /4k + 11/ is prime,
  and ten values where /4k + 11/ is nonprime.
#+end_note
#+begin_info
  Prime: 11, 15, 19, 23, 31, 39, 43, 59, 67, 71, 79
  Non-Prime: 27, 35, 47, 51, 55, 63, 75, 87, 91, 99
#+end_info
#+BEGIN_SRC elisp :reults list
  (loop for k upto 100
  collect (+ (* 4 k) 11))
#+END_SRC

#+RESULTS:
| 11 | 15 | 19 | 23 | 27 | 31 | 35 | 39 | 43 | 47 | 51 | 55 | 59 | 63 | 67 | 71 | 75 | 79 | 83 | 87 | 91 | 95 | 99 | 103 | 107 | 111 | 115 | 119 | 123 | 127 | 131 | 135 | 139 | 143 | 147 | 151 | 155 | 159 | 163 | 167 | 171 | 175 | 179 | 183 | 187 | 191 | 195 | 199 | 203 | 207 | 211 | 215 | 219 | 223 | 227 | 231 | 235 | 239 | 243 | 247 | 251 | 255 | 259 | 263 | 267 | 271 | 275 | 279 | 283 | 287 | 291 | 295 | 299 | 303 | 307 | 311 | 315 | 319 | 323 | 327 | 331 | 335 | 339 | 343 | 347 | 351 | 355 | 359 | 363 | 367 | 371 | 375 | 379 | 383 | 387 | 391 | 395 | 399 | 403 | 407 | 411 |

** DONE FOJ
   CLOSED: [2019-02-14 Thu 16:01]
#+begin_note
  CCS = Consecutive Composite Sequence.

  What is the first CCS of length 2? 3? 4? 10?
:HINT:
  - Hint :: This is a potentially tricky series of questions.
:END:
#+end_note
#+begin_info 
  2. 8, 9 
  3. 8, 9, 10
  4. 24, 25, 26, 27
  10. 114, 115, 116, 117, 118, 119, 120, 121, 122, 123
#+end_info
** DONE VAR
   CLOSED: [2019-02-14 Thu 16:03]
#+begin_note
  Browse the linked information on [[https://en.wikipedia.org/wiki/Highly_composite_number][highly composite numbers]]. Find the video
  about the synonymous \ldquo{}anti-primes\rdquo and watch it. What is your favorite HCN (or
  anti-prime)? Is it divisible by at least 10 distinct primes?
#+end_note
#+begin_info
  I like 10080, because it's 2*2*2*2*2
#+end_info
** DONE VAY
   CLOSED: [2019-02-14 Thu 16:16]
#+begin_note
  Trace through the steps of each of these GCD calculations:

  | # |   a |   b | (gcd a b) |
  |---+-----+-----+-----------|
  | 1 |  57 |  43 |         1 |
  | 2 | 501 |  39 |         3 |
  | 3 | 765 | 110 |         5 |
  | 4 | 899 | 493 |        29 |
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
  1. 57/43 = 1 r 14; 43/14 = 3 r 1; 14/1 = 14 r 0, b = 1 gcd = 1
  2. 501/39 = 12 r 33; 39/33 = 1 r6; 33/6 = 5 r 3; 6/3 = 2; 3 = b = gcd
  3. 765/110 = 6 r 105; 110/105 = 1 r 5; 105/5 = 21; gcd = b = 5
  4. 899/493 = 1 r 406; 493/406 = 1 r 87; 406/87 = 4 r 58, 87/58 = 1 r 29; 58/29 = 2, gcd = b = 29
#+end_info
** DONE FQW
   CLOSED: [2019-02-14 Thu 16:18]
#+begin_note
  PVP what the following returns:

#+BEGIN_SRC elisp :results silent
  (and (= (gcd 56 8) 8)
       (= (gcd 65 15) 5)
       (= (lcm 5 7) 35)
       (= (lcm 4 6) 12))
#+END_SRC
:HINT:
  - Hint :: This is a very straightforward exercise.
:END:
#+end_note
#+begin_info
  It tests if the second number is the gcd or lcm of the thing calculated within.  If everything
  is true, the function returns true.
#+end_info
** DONE VCR
   CLOSED: [2019-02-14 Thu 16:23]
#+begin_note
  Verify that for many pairs of positive integers =a= and =b=:

#+BEGIN_SRC elisp :results silent
  (= (* (gcd a b) (lcm a b)) (* a b))
#+END_SRC

  Does this equality necessarily hold for /all/ pairs of positive integers? Why
  or why not?
#+end_note
#+begin_info
  True
#+end_info
#+BEGIN_SRC elisp :results raw
    (loop for a upto 100
    (loop for b upto 100
    collect (= (* (gcd a b) (lcm a b)) (* a b))))

#+END_SRC
** DONE FRM
   CLOSED: [2019-02-14 Thu 16:24]
#+begin_note
  Given that (a slight expansion of) the CSF of /a/ is 2^3 \cdot 3^2 \cdot 5^1
  \cdot 7^0 and the CSF of /b/ is 2^2 \cdot 3^3 \cdot 5^0 \cdot 7^1, give the CSFs of the
  GCD, the LCM, and the product of /a/ and /b/. Then flesh out the following
  code using map instead of loops:

#+BEGIN_SRC elisp :results silent
  (defun gcd-lcm-ab (a-in-csf b-in-csf)
    (let* ((a-csf-powers ...)
           (b-csf-powers ...)
           (gcd-of-a-and-b-in-csf ...)
           (lcm-of-a-and-b-in-csf ...)
           (product-of-a-and-b-in-csf ...))
      (list gcd-of-a-and-b-in-csf
            lcm-of-a-and-b-in-csf
            product-of-a-and-b-in-csf)))
#+END_SRC

  Does doing this exercise help you see the answer to the previous one?
:HINT:
  - Hint :: Use =mapcar= and =mapcar*= with some suitable =lambda= functions.
:END:
#+end_note
#+begin_info
  Yes!
#+end_info

** DONE ITT
   CLOSED: [2019-02-12 Tue 09:27]
#+begin_note
  How many divisors does a given number have?

  Take 36. By trial division (trying successive divisors, starting with 1, which
  remember divides everything) we see that

  36 =
#+begin_verse
  1 ⋅ 36 (that’s 2),
  2 ⋅ 18 (another 2),
  3 ⋅ 12 (2 more),
  4 ⋅ 9 (2 more),
  6 ⋅ 6 (1 more — no double counting!)
#+end_verse
  --- which totals 9 divisors.

  What is a general method for finding this total divisor count for any positive
  number?
#+end_note
#+begin_info
  One sequences through integers in order, and if the answer results in an integer, 
  it can be considered a divisor.
#+end_info
** DONE IYJ
   CLOSED: [2019-02-14 Thu 16:50]
#+begin_note
  How many 7-digit primes have the form n^2 + 1? What are they?
:HINT:
  - Time Hint :: This hard problem is potentially time-consuming.
:END:
#+end_note
#+begin_info
  I dont think there are any, I tested it in excel.
#+end_info
** DONE IZL
   CLOSED: [2019-02-14 Thu 16:54]
#+begin_note
  Not the first, nor the only one, but this function (with its =factorial=
  helper) gives one such CCS:

#+BEGIN_SRC elisp :results silent
  (defun factorial (n)
    (if (zerop n)
        1
      (* n (factorial (- n 1)))))

  (defun consecutive-composite-sequence-of-length (r)
    (let ((r+1-factorial (factorial (1+ r))))
      (loop for n from 1 to r
            collect (+ r+1-factorial n 1))))
#+END_SRC

  Write code (e.g., flesh out)

#+BEGIN_SRC elisp :results silent
  (defun all-composite (r) ...)
#+END_SRC

  to verify that the above defined sequence contains only composites. Note that
  in a sequence of consecutive numbers, every other one is even, hence
  composite, every third one is a multiple of 3, hence composite, etc. But is
  there a better way to see this than sifting through the sequence looking for
  primes somehow hiding among all those composites? Why or why not?
:PYTHON-HINT:
#+BEGIN_SRC python :results output
from math import *
def isPrime(n):
    for i in range(2,int(sqrt(n))+1):
        if n % i == 0:
            return False
    return True

def allComp(n):
  for i in n:
    if isPrime(i):
      return False
  return True

comp = [39916802, 39916803, 39916804, 39916805, 39916806, 39916807, 39916808, 39916809, 39916810, 39916811]
print(allComp(comp))
#+END_SRC
:END:
#+end_note
#+begin_info
  I think that if you are blind to where prime numbers lie, this is a good way of figuring it out.
  However, if you know there is a priem within a certain range, you could simplify the function to only
  include those numbers, saving a great deal of processing power.
#+end_info
** DONE VAO
   CLOSED: [2019-02-14 Thu 17:05]
#+begin_note
  Pierre de Fermat found a way of finding factors of a number. It is based on
  certain assumptions. Study the code below and articulate what these
  assumptions are.

#+BEGIN_SRC elisp :results silent
  (defun maybe-find-factorization (number limit)
    (mapc (lambda (n)
            (let* ((a (floor (sqrt number)))
                   (s (+ a n))
                   (x (sqrt (- (* s s) number))))
              (when (= x (floor x))
                (princ (format "n = %d, a = %d, s = %d, x = %d,
   factor1 = s - x = %d,
   factor2 = s + x = %d\n"
                               n a s x (- s x) (+ s x))))))
          (number-sequence 1 limit)))
#+END_SRC

#+BEGIN_SRC elisp :results output
  (maybe-find-factorization 125 10)
#+END_SRC

: n = 4, a = 11, s = 15, x = 10,
:  factor1 = s - x = 5,
:  factor2 = s + x = 25
:HINT:
  - Hint :: Did you look at the [[https://en.wikipedia.org/wiki/Fermat%2527s_factorization_method][Wikipedia Page]]?
:END:
#+end_note
#+begin_info
  It assumes that the numbers that s and x associate with are close together so the calculation
  does not take as long.
#+end_info

** Week 7
#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2019-02-21 Fri 16:31]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *5:40* |
#+END:
** DONE GMQ
   CLOSED: [2019-02-21 Thu 15:49]
#+begin_note
  First recall (or look up) how the =&rest= keyword works, e.g.:

#+BEGIN_SRC elisp :results silent
  (defun printf (format-directive &rest args)
    (princ (apply 'format format-directive args)))
#+END_SRC

  Now explain what this code does after trying it on a few tests:

#+BEGIN_SRC elisp :results silent
  (defun mystery (&rest numbers)
    (loop for n from 0 to (apply '* numbers)
          do (printf "%3d <--> %s\n" n
                     (loop for m in numbers collect (mod n m)))))
#+END_SRC

#+BEGIN_SRC elisp :results output
  (mystery 3 5)
#+END_SRC

#+BEGIN_SRC elisp :results output
  (mystery 4 6)
#+END_SRC

  Replace ='*= with ='lcm= and do the same calls again. Explain what you
  observed, and come up with a better name for the =mystery= function.
:HINT:
  - Hint :: In your source code blocks, use the header directive =:results
            output= for best results, e.g.:
: #+BEGIN_SRC elisp :results output
  - Peek Ahead Hint :: PQU
:END:
#+end_note
#+begin_info
  This creates a list of all numbers from zero to the least common multiple of the two numbers 
  you input.  In short, it displays all the possible mods of the two numbers, then stops when 
  both have an output of zero.
#+end_info
#+BEGIN_SRC emacs-lisp :results silent
 (defun printf (format-directive &rest args)
 (princ (apply 'format format-directive args)))
#+END_SRC
#+BEGIN_SRC emacs-lisp :results output
(printf "%s" '"hello there" '"my name is bryan" '"these are rest args")
#+END_SRC

#+RESULTS:
: hello there

#+BEGIN_SRC emacs-lisp :results silent
(defun mystery (&rest numbers)
  (loop for n from 0 to (apply 'lcm numbers)
        do (printf "%3d <--> %s\n" n
                   (loop for m in numbers collect (mod n m)))))
#+END_SRC
#+BEGIN_SRC elisp :results output
  (mystery 3 5)
#+END_SRC

#+RESULTS:
#+begin_example
  0 <--> (0 0)
  1 <--> (1 1)
  2 <--> (2 2)
  3 <--> (0 3)
  4 <--> (1 4)
  5 <--> (2 0)
  6 <--> (0 1)
  7 <--> (1 2)
  8 <--> (2 3)
  9 <--> (0 4)
 10 <--> (1 0)
 11 <--> (2 1)
 12 <--> (0 2)
 13 <--> (1 3)
 14 <--> (2 4)
 15 <--> (0 0)
#+end_example
** GMY
#+begin_note
  Replace the =;;...= line with three lines, binding the values of =y1=, =y2= and
  =y3=. Write a helper function to compute these values.

#+BEGIN_SRC elisp
  (let* ((r1 4)
         (r2 2)
         (r3 9)
         (m1 7)
         (m2 11)
         (m3 13)
         (m (* m1 m2 m3))
         (o1 (/ m m1))
         (o2 (/ m m2))
         (o3 (/ m m3))
         ;;...
         )
    (mod (+ (* r1 o1 y1) (* r2 o2 y2) (* r3 o3 y3)) m))
#+END_SRC
:HINT:
  - Hint :: The y\rsquo{}s are just the MMIs of the o\rsquo{}s mod the m\rsquo{}s. The helper
            function should use the Extended Euclidean GCD algorithm to compute
            these MMIs.
:END:
#+end_note
#+begin_info
  
#+end_info

#+BEGIN_SRC elisp :results raw
(require 'cl) ;; for destructuring-bind

(defun egcd (a b)
  "Computes the greatest common divisor of a and b recursively.
   This extended version returns a list of d, x and y, where
   d = ax + by = gcd(a, b)."
  (if (zerop b)
      (list a 1 0)
    (let ((q (/ a b))
          (r (% a b)))
      (destructuring-bind (d x y) (egcd b r)
        (list d y (- x (* q y)))))))

  (let* ((r1 4)
         (r2 2)
         (r3 9)
         (m1 7)
         (m2 11)
         (m3 13)
         (m (* m1 m2 m3))
         (o1 (/ m m1))
         (o2 (/ m m2))
         (o3 (/ m m3))
         (y1 (find-y o1 m1))
         (y2 (find-y o2 m2))
         (y3 (find-y o3 m3)) 
    (mod (+ (* r1 o1 y1) (* r2 o2 y2) (* r3 o3 y3)) m)))

(defun find-y (o m)
   (let* ((equat (egcd o m)))
         (if (= (nth 0 equat) 1)
             (mod (nth 1 equat) m)
             ("no solutions"))
   ))

#+END_SRC
** DONE JQA
   CLOSED: [2019-02-21 Thu 15:39]
#+begin_note
   What is a 3-digit positive simultaneous solution to the following system of
   linear congruences?

   x \equiv_7 3

   x \equiv_{11} 5

   x \equiv_{13} 4
#+end_note
#+begin_info
  654
#+end_info
#+BEGIN_SRC elisp :results silent
  (defun rns (n)
  (list (mod n 7) (mod n 11) (mod n 13)))
#+END_SRC
#+BEGIN_SRC elisp
  (defun from-rns (rns-triple)
(car (rassoc rns-triple rns-alist)))
#+END_SRC

#+RESULTS:
: from-rns

#+END_SRC
#+BEGIN_SRC elisp
  (setq rns-alist
  (loop for x from 0 to 1001
  for y = (rns x)
  collect (append (list x) y)))
#+END_SRC
#+BEGIN_SRC elisp :results raw
  (from-rns '(0 8 12))
#+END_SRC

#+RESULTS:
987
212
794
654

#+BEGIN_SRC elisp :results silent
  (defun to-rns (rns-num)
  (cdr (assoc rns-num rns-alist)))
#+END_SRC
#+BEGIN_SRC elisp
  (to-rns 555)
#+END_SRC

#+RESULTS:
| 2 | 5 | 9 |

#+END_SRC
** DONE GRZ
   CLOSED: [2019-02-21 Thu 15:39]
#+begin_note
   What is a 3-digit positive simultaneous solution to the following system of
   linear congruences?

   x \equiv_7 3

   x \equiv_{11} 2

   x \equiv_{13} 1
#+end_note
#+begin_info
  794
#+end_info
** DONE JYA
   CLOSED: [2019-02-21 Thu 15:40]
#+begin_note
   What is a 3-digit positive simultaneous solution to the following system of
   linear congruences?

   x \equiv_7 2

   x \equiv_{11} 3

   x \equiv_{13} 4
#+end_note
#+begin_info
  212
#+end_info
** DONE GXF
   CLOSED: [2019-02-21 Thu 15:40]
#+begin_note
   What is a 3-digit positive simultaneous solution to the following system of
   linear congruences?

   x \equiv_7 0

   x \equiv_{11} 8

   x \equiv_{13} 12
#+end_note
#+begin_info
  987
#+end_info

** DONE JPZ
   CLOSED: [2019-02-21 Thu 16:12]
#+begin_note
  If p and q are coprime positive integers, then does a bijection necessarily
  exist between $\mathbb{Z}_{pq}$ and $\mathbb{Z}_{p} \times \mathbb{Z}_{q}$?

  Explain what the following code does, and how:
#+BEGIN_SRC elisp
  (let* ((p 3)
         (q 5)
         (z-pq (number-sequence 0 (* p q))))
      (mapcar* 'list z-pq
               (mapcar (lambda (n) (mod n p)) z-pq)
               (mapcar (lambda (n) (mod n q)) z-pq)))
#+END_SRC

  Imagine the above code were wrapped in a function definition with p and q
  passed as parameters instead of bound in the =let=, then compare this function
  to the =mystery= function. Which function would be more in the functional
  programming style?
#+end_note
#+begin_info
  This function does the same exact thing as the first exercise, but it uses mapping 
  instead of looping.  This is a better example of a functional program.
#+end_info
#+BEGIN_SRC elisp
  (let* ((p 3)
       (q 5)
       (z-pq (number-sequence 0 (* p q))))
    (mapcar* 'list z-pq
             (mapcar (lambda (n) (mod n p)) z-pq)
             (mapcar (lambda (n) (mod n q)) z-pq)))
#+END_SRC

#+RESULTS:
|  0 | 0 | 0 |
|  1 | 1 | 1 |
|  2 | 2 | 2 |
|  3 | 0 | 3 |
|  4 | 1 | 4 |
|  5 | 2 | 0 |
|  6 | 0 | 1 |
|  7 | 1 | 2 |
|  8 | 2 | 3 |
|  9 | 0 | 4 |
| 10 | 1 | 0 |
| 11 | 2 | 1 |
| 12 | 0 | 2 |
| 13 | 1 | 3 |
| 14 | 2 | 4 |
| 15 | 0 | 0 |

** DONE XFO
   CLOSED: [2019-02-21 Thu 16:20]
#+begin_note
  The Chinese Remainder Theorem makes possible the use of a /residue number
  system/ to do computer arithmetic with \ldquo{}large\rdquo integers, where largeness is
  relative. Large in practice means numbers with hundreds or thousands of
  digits. For this problem, large means no greater than 1000. Normally,
  arithmetic with numbers in this range would be trivial, but the normal
  arithmetic operations of addition, subtraction, and multiplication are to be
  viewed as quite expensive. You must find ways to avoid using them.
  Exponentially more expensive are the division and modulus operations --- avoid
  these especially!

  Use the code below as a guide and a starting point, finish implementing the
  =to-rns=, =from-rns=, =add2= and =mul2= functions, and then in separate code
  blocks, write test code that can correctly add and multiply one-, two-, and
  three-digit nonnegative integers, converting to rns, doing the rns operations,
  then converting back from rns.

  /Avoid at all costs/ the use of =+=, =-=, =*=, =/=, =%=, or =mod=!

  You will benefit greatly if you write helper functions and use good functional
  programming style throughout.

#+BEGIN_SRC elisp
  (defun to-rns (n)
    "Convert a normal integer between 0 and 1000 to its rns modulo
    1001 representation."
    )

  (defun from-rns (rns)
    "Convert from an rns modulo 1001 integer back to its normal
    representation."
    )

  (defun add2 (rns1 rns2)
    "Add two rns modulo 1001 integers to produce their rns sum."
    )

  (defun mul2 (rns1 rns2)
    "Multiply two rns modulo 1001 integers to produce their rns
    product."
    )
#+END_SRC

  The rest of the code is good as is. Note the mention in the documentation of
  the $\mathbb{Z}_7$, $\mathbb{Z}_{11}$, and $\mathbb{Z}_{13}$ residue sets. Recall
  that a $\mathbb{Z}_n$ residue set is just the possible remainders when modding
  by n, i.e., [0 1 2 3 \dots n-1].

#+BEGIN_SRC elisp
  (defun a7 (i j)
    "Add two nonnegative integers in the Z_7 residue set to produce
     a sum in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal addition/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 7) (< j 7))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[0 1 2 3 4 5 6]
                 [1 2 3 4 5 6 0]
                 [2 3 4 5 6 0 1]
                 [3 4 5 6 0 1 2]
                 [4 5 6 0 1 2 3]
                 [5 6 0 1 2 3 4]
                 [6 0 1 2 3 4 5]] i) j))

  (defun a11 (i j)
    "Add two nonnegative integers in the Z_11 residue set to produce
     a sum in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal addition/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 11) (< j 11))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[ 0  1  2  3  4  5  6  7  8  9 10]
                 [ 1  2  3  4  5  6  7  8  9 10  0]
                 [ 2  3  4  5  6  7  8  9 10  0  1]
                 [ 3  4  5  6  7  8  9 10  0  1  2]
                 [ 4  5  6  7  8  9 10  0  1  2  3]
                 [ 5  6  7  8  9 10  0  1  2  3  4]
                 [ 6  7  8  9 10  0  1  2  3  4  5]
                 [ 7  8  9 10  0  1  2  3  4  5  6]
                 [ 8  9 10  0  1  2  3  4  5  6  7]
                 [ 9 10  0  1  2  3  4  5  6  7  8]
                 [10  0  1  2  3  4  5  6  7  8  9]] i) j))

  (defun a13 (i j)
    "Add two nonnegative integers in the Z_13 residue set to produce
     a sum in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal addition/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 13) (< j 13))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
                 [ 1  2  3  4  5  6  7  8  9 10 11 12  0]
                 [ 2  3  4  5  6  7  8  9 10 11 12  0  1]
                 [ 3  4  5  6  7  8  9 10 11 12  0  1  2]
                 [ 4  5  6  7  8  9 10 11 12  0  1  2  3]
                 [ 5  6  7  8  9 10 11 12  0  1  2  3  4]
                 [ 6  7  8  9 10 11 12  0  1  2  3  4  5]
                 [ 7  8  9 10 11 12  0  1  2  3  4  5  6]
                 [ 8  9 10 11 12  0  1  2  3  4  5  6  7]
                 [ 9 10 11 12  0  1  2  3  4  5  6  7  8]
                 [10 11 12  0  1  2  3  4  5  6  7  8  9]
                 [11 12  0  1  2  3  4  5  6  7  8  9 10]
                 [12  0  1  2  3  4  5  6  7  8  9 10 11]] i) j))

  (defun m7 (i j)
    "Multiply two nonnegative integers in the Z_7 residue set to produce
     a product in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal multiplication/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 7) (< j 7))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[0  0  0  0  0  0  0]
                 [0  1  2  3  4  5  6]
                 [0  2  4  6  1  3  5]
                 [0  3  6  2  5  1  4]
                 [0  4  1  5  2  6  3]
                 [0  5  3  1  6  4  2]
                 [0  6  5  4  3  2  1]] i) j))

  (defun m11 (i j)
    "Multiply two nonnegative integers in the Z_11 residue set to produce
     a product in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal multiplication/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 11) (< j 11))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[0  0  0  0  0  0  0  0  0  0  0]
                 [0  1  2  3  4  5  6  7  8  9 10]
                 [0  2  4  6  8 10  1  3  5  7  9]
                 [0  3  6  9  1  4  7 10  2  5  8]
                 [0  4  8  1  5  9  2  6 10  3  7]
                 [0  5 10  4  9  3  8  2  7  1  6]
                 [0  6  1  7  2  8  3  9  4 10  5]
                 [0  7  3 10  6  2  9  5  1  8  4]
                 [0  8  5  2 10  7  4  1  9  6  3]
                 [0  9  7  5  3  1 10  8  6  4  2]
                 [0 10  9  8  7  6  5  4  3  2  1]] i) j))

  (defun m13 (i j)
    "Multiply two nonnegative integers in the Z_13 residue set to produce
     a product in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal multiplication/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 13) (< j 13))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[0  0  0  0  0  0  0  0  0  0  0  0  0]
                 [0  1  2  3  4  5  6  7  8  9 10 11 12]
                 [0  2  4  6  8 10 12  1  3  5  7  9 11]
                 [0  3  6  9 12  2  5  8 11  1  4  7 10]
                 [0  4  8 12  3  7 11  2  6 10  1  5  9]
                 [0  5 10  2  7 12  4  9  1  6 11  3  8]
                 [0  6 12  5 11  4 10  3  9  2  8  1  7]
                 [0  7  1  8  2  9  3 10  4 11  5 12  6]
                 [0  8  3 11  6  1  9  4 12  7  2 10  5]
                 [0  9  5  1 10  6  2 11  7  3 12  8  4]
                 [0 10  7  4  1 11  8  5  2 12  9  6  3]
                 [0 11  9  7  5  3  1 12 10  8  6  4  2]
                 [0 12 11 10  9  8  7  6  5  4  3  2  1]] i) j))
#+END_SRC

#+RESULTS:
: m13

:HINT:
  - Hint :: For =to-rns= and =from-rns=, =assoc= and =rassoc= are recommended.
            Thus the creation of an association list (alist) is a prerequisite
            for using these functions. The challenge is to create this alist
            without using mod (or %) or loops.
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
Functions to use:
apply
vconcat
mapcar*
vector

(mapcar 'documentation (mapcar 'intern (mapcar 'car funcs)))

apply 'vconcat mapcar* 'vector 
#+BEGIN_SRC elisp :results silent
  (defun shuffle (&rest sequences)
  (apply 'vconcat (apply 'mapcar* 'vector sequences)))
#+END_SRC
#+BEGIN_SRC elisp :results raw
  (shuffle [A B C] [x y z] '(1 2))
#+END_SRC

#+RESULTS:
[A x 1 B y 2]
[A x 1 B y 2 C z 3]
[A x B y C z]
[[A B C] [x y z]]

  (shuffle [A B C] [1 2 3)
#+END_SRC

#+BEGIN_SRC elisp :results silent
  (defun rns (n)
  (list (mod n 7) (mod n 11) (mod n 13)))
#+END_SRC
#+BEGIN_SRC elisp
  (defun from-rns (rns-triple)
(car (rassoc rns-triple rns-alist)))
#+END_SRC

#+END_SRC
#+BEGIN_SRC elisp
  (setq rns-alist
  (loop for x from 0 to 1001
  for y = (rns x)
  collect (append (list x) y)))
#+END_SRC
#+BEGIN_SRC elisp :results raw
  (from-rns '(0 8 12))
#+END_SRC

#+BEGIN_SRC elisp :results silent
  (defun to-rns (rns-num)
  (cdr (assoc rns-num rns-alist)))
#+END_SRC
#+BEGIN_SRC elisp
  (to-rns 555)
#+END_SRC
For this part, I consulted my roomate Brian!
#+BEGIN_SRC emacs-lisp :results silent
  (defun add2 (i j)
  (list (a7 (nth 0 i) (nth 0 j)) (a11 (nth 1 i) (nth 1 j)) (a13 (nth 2 i) (nth 2 j))))
    

  (defun mul2 (i j)
  (list (a7 (nth 0 i) (nth 0 j)) (a11 (nth 1 i) (nth 1 j)) (a13 (nth 2 i) (nth 2 j))))
#+END_SRC
#+BEGIN_SRC elisp :results list
  (add2 '(1 2 3) '(4 5 6))
#+END_SRC

#+RESULTS:
- 5
- 7
- 9

** Week 8
#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2019-02-28 Thu 16:57]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *4:35* |
#+END:
  Exercise, to be precise.
** DONE GYN
   CLOSED: [2019-02-28 Thu 15:31]
#+begin_note
  Help Abu and Ila out. This version of =mod-expt= gets a /little/ better
  mileage than their simplistic one. It keeps the numbers smaller by reducing
  each partial exponentiation by modding it once every iteration instead of once,
  period. What fact or facts of modular arithmetic justify this?

#+BEGIN_SRC elisp :results silent
  (defun a-better-mod-expt (base power modulus)
    (loop with result = 1
          for n from 1 to power
          do (setq result (mod (* result base) modulus))
          finally return result))
#+END_SRC
:HINT:
  - Hint :: Reread the interchange between Til, Abu and Ila in PQS.
:END:
#+end_note
#+begin_info
  So this function works by using the modular arithmetic rule that when finding a modulus,
  you can employ the property taht works as follows: Say you want to find 94 mod 5.  You can
  split that up into as many seperate problems as you'd like in order to get that answer.  For
  this example, I'll split it in three.  33 % 5 = 3, so if we take (33%5 + 33%5 + 28%5) % 5, we get
  the answer of 9 % 5 which is equal to 4.  This is what the above loop does, but at each step of
  the exponent!  This saves a significant amount of processing power!
#+end_info
#+BEGIN_SRC elisp
  (a-better-mod-expt 2 3 5)
#+END_SRC

#+RESULTS:
: 2

  Problem, to be precise.
** XGG
#+begin_note
  Experiment with RSA using the following code. You will need a better modular
  exponentiation function than =mod-expt= or perhaps even =a-better-mod-expt=.
  Implement the =pow-mod= function to be this better version. Note the
  difference between /encoding/ and /encryption/, and between /decryption/ and
  /decoding/.

  How \ldquo{}big\rdquo a message can you successfully round-trip?

#+BEGIN_SRC elisp :results silent
  (defun rsa-encrypt (message n e &optional encoder)
    (let* ((message-encoded (funcall (or encoder 'identity) message))
           (encrypted (pow-mod message-encoded e n)))
      encrypted))

  (defun rsa-decrypt (encrypted n d &optional decoder)
    (let* ((decrypted (pow-mod encrypted d n))
           (message-decoded (funcall (or decoder 'identity) decrypted)))
      message-decoded))

  (defun round-trip (message n e d &optional encoder decoder)
    (equal message
           (rsa-decrypt (rsa-encrypt message n e encoder)
                        n d decoder)))
#+END_SRC

  You will need working =from-base-27= and =to-base-27= functions, as well as a
  working knowledge of /symbol property lists/ to play with /this/ test code:

#+BEGIN_SRC elisp
  (defun test-rsa (message-with-spaces)
    (let* ((message (mapconcat 'identity
                               (split-string message-with-spaces " ") "@"))
            (n (get 'rsa-players :n))
            (e (get 'rsa-players :e))
            (d (get 'rsa-players :d))
            (encrypted (rsa-encrypt message n e 'from-base-27))
            (decrypted (rsa-decrypt encrypted n d 'to-base-27))
            (decrypted-message-with-spaces
             (mapconcat 'identity (split-string decrypted "@") " "))
            (success (string= message-with-spaces
                              decrypted-message-with-spaces)))
       (princ (format (concat "\"%s\"\nwas encoded and encrypted as\n%s\n"
                              "then decrypted and decoded as\n\"%s\"\n")
                      message-with-spaces
                      encrypted
                      decrypted-message-with-spaces))
       (princ (if success "" "un"))
       (princ "successfully.\n")
       success))
#+END_SRC
:HINT:
  - Hint :: This will be discussed in class.
:END:
#+end_note
#+begin_info
  Your answer goes here.
#+end_info

#+BEGIN_SRC elisp :results silent
(defun abr (n b)
  (let ((d (/ n b))
        (m (mod n b)))
    (if (zerop d)
        (list m)
      (append (abr d b) (list m)))))

  (defun to-base-27 (base-10-num)
    (mapconcat (lambda (n) (char-to-string (+ ?@ n))) (abr base-10-num 27) ""))
  (defun reconstruct-number-from-abr (list-of-coeff base)
   (if (null list-of-coeff)
      0
      (+ (car list-of-coeff)
         (* base (reconstruct-number-from-abr (cdr list-of-coeff) base)))))
  (defun from-base-27 (base-27-string)
    (reconstruct-number-from-abr (reverse (mapcar (lambda (n) (- n ?@)) base-27-string)) 27))
 
  (defun pow-mod (base power modulus)
   (

#+END_SRC


#+BEGIN_SRC elisp
  (from-base-27 "SUPERHOT")
#+END_SRC

#+RESULTS:
: 207115141394

#+BEGIN_SRC elisp :results show
  (to-base-27 207115141394) 
#+END_SRC

#+RESULTS:
: SUPERHOT


#+BEGIN_SRC elisp :results silent
  (defun rsa-encrypt (message n e &optional encoder)
    (let* ((message-encoded (funcall (or encoder 'identity) message))
           (encrypted (pow-mod message-encoded e n)))
      encrypted))

  (defun rsa-decrypt (encrypted n d &optional decoder)
    (let* ((decrypted (pow-mod encrypted d n))
           (message-decoded (funcall (or decoder 'identity) decrypted)))
      message-decoded))

  (defun round-trip (message n e d &optional encoder decoder)
    (equal message
           (rsa-decrypt (rsa-encrypt message n e encoder)
                        n d decoder)))
#+END_SRC

  You will need working =from-base-27= and =to-base-27= functions, as well as a
  working knowledge of /symbol property lists/ to play with /this/ test code:

#+BEGIN_SRC elisp :results silent
(setf (get 'rsa-players :p) 11)
(setf (get 'rsa-players :q) 17)
(setf (get 'rsa-players :n) (* (get 'rsa-players :p) (get 'rsa-players :q)))
(setf (get 'rsa-players :t) (* (- (get 'rsa-players :p) 1) (- (get 'rsa-players :q) 1)))
(setf (get 'rsa-players :e) '13)
(setf (get 'rsa-players :d) '37)


  (defun test-rsa (message-with-spaces)
    (let* ((message (mapconcat 'identity
                               (split-string message-with-spaces " ") "@"))
            (n (get 'rsa-players :n))
            (e (get 'rsa-players :e))
            (d (get 'rsa-players :d))
            (encrypted (rsa-encrypt message n e 'from-base-27))
            (decrypted (rsa-decrypt encrypted n d 'to-base-27))
            (decrypted-message-with-spaces
             (mapconcat 'identity (split-string decrypted "@") " "))
            (success (string= message-with-spaces
                              decrypted-message-with-spaces)))
       (princ (format (concat "\"%s\"\nwas encoded and encrypted as\n%s\n"
                              "then decrypted and decoded as\n\"%s\"\n")
                      message-with-spaces
                      encrypted
                      decrypted-message-with-spaces))
       (princ (if success "" "un"))
       (princ "successfully.\n")
       success))
#+END_SRC
#+BEGIN_SRC elisp :results output
  (test-rsa "Is")
#+END_SRC

#+RESULTS:
: "Is"
: was encoded and encrypted as
: 105
: then decrypted and decoded as
: "CZ"
: unsuccessfully.

** Week 9

** Week 10

** Week 11

** Week 12

** Week 13

* Other                                                            :noexport:
  This document may be modified by the instructor at any time without notification.
  
